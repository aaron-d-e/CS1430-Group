// Intergrate Sound with SDL_Plotter
void Ball::Physics(float dT, SDL_Plotter& plotter) {
  yVelocity += (GRAVITY * dT);

  y += yVelocity * dT;
  x += xVelocity * dT;

  //horizontal collision
  if (x <= radius || x >= 1000 - radius) {
    xVelocity *= -BOUNCINESS;
    x = (x <= radius) ? radius : 1000 - radius;

    plotter.playSound("bounce.wav");
    }
  }
}

//Main game loop intergration - coming later

//Force changes only in wanted
force gravity(9.8, -PI / 2);
force userForce;

void Ball::applyForce(const force& f) {
  float ax = f.getMagnitude() * cos(f.getDirection());
  float ay = f.getMagnitude() * sin(f.getDirection());
}




#include <SDL_mixer.h>

class Ball {
public: 
  float x, y;
  float xVelocity, yVelocity;
  const float GRAVITY = 9.8f;

  Ball() : x(0), y(0), xVelocity(0), yVelocity(0) {}

  void Physics(float dT, float surfaceY) {
    yVelocity += (GRAVITY * dt);
    y += yVelocity * dT;
    x += xVelocity * dT;

    CheckCollision(surfaceY);
  }

  void CheckCollision(float surfaceY) {
    if (y >= surfaceY) {
      y = surfaceY;
      yVelocity = -yVelocity * 0.8f;

      // Play bounce sound
      Mix_Chunk* bounceSound = Mix_LoadWAV("bounce.wav");
      if (bounceSound != nullptr) {
        Mix_PlayChannel(-1, bounceSound, 0);
        Mix_FreeChunk(bounceSound);
      }
    }
  }
};


//Intergrate physics in main loop and collision detection
