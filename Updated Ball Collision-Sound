// Intergrate Sound with SDL_Plotter
void Ball::Physics(float dT, SDL_Plotter& plotter) {
  yVelocity += (GRAVITY * dT);

  y += yVelocity * dT;
  x += xVelocity * dT;

  //horizontal collision
  if (x <= radius || x >= 1000 - radius) {
    xVelocity *= -BOUNCINESS;
    x = (x <= radius) ? radius : 1000 - radius;

    plotter.playSound("bounce.wav");
    }
  }
}

//Main game loop intergration - with color to be tested
#include <SDL.h>
#include "SDL_Functions.h"
#include "SDL_Plotter.h"

int main(int argc, char* argv[]) {
  SDL_Plotter plotter(1000, 1000);
plotter.initSound("bouce.wav");

SDL_Color ballColor = {255, 0, 0, 255};
Ball ball(500, 500, 1.0, -1.0, 20.0, ballColor);

bool running = true;
while(running) {
  if (plotter.kbhit()) {
    char key = plotter.getKey();
    if (key == 'q') {
      running = false; // Quit on 'q'
    }
    ball.Physics(0.016f, plotter);

    plotter.clear();
    ball.render(plotter.getRenderer());
    plotter.update();

  }

  plotter.quitSound("bounce.wav");
  return 0;
}

//Force changes only in wanted
force gravity(9.8, -PI / 2);
force userForce;

void Ball::applyForce(const force& f) {
  float ax = f.getMagnitude() * cos(f.getDirection());
  float ay = f.getMagnitude() * sin(f.getDirection());
}




#include <SDL_mixer.h>

class Ball {
public: 
  float x, y;
  float xVelocity, yVelocity;
  const float GRAVITY = 9.8f;

  Ball() : x(0), y(0), xVelocity(0), yVelocity(0) {}

  void Physics(float dT, float surfaceY) {
    yVelocity += (GRAVITY * dt);
    y += yVelocity * dT;
    x += xVelocity * dT;

    CheckCollision(surfaceY);
  }

  void CheckCollision(float surfaceY) {
    if (y >= surfaceY) {
      y = surfaceY;
      yVelocity = -yVelocity * 0.8f;

      // Play bounce sound
      Mix_Chunk* bounceSound = Mix_LoadWAV("bounce.wav");
      if (bounceSound != nullptr) {
        Mix_PlayChannel(-1, bounceSound, 0);
        Mix_FreeChunk(bounceSound);
      }
    }
  }
};


//Intergrate physics in main loop and collision detection
